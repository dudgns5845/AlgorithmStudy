#topdown 방식보다는 피보나치 수열과 같이 bottomup 방식을 사용해야하는 문제

#연산하려는 입력값 받기
input = int(input())

#  1부터 x까지 반복문을 돌면서 최소 연산을 확인하는데 
#  메모리 제이션을 통해서 이전 값과 최소 연산을 업데이트 하면서 연산의 중복을 방지


# 메모리 제이션 공간 할당 => 교제에서는 dp 테이블이라고 함
mem = [0]*100000 

# 1 은 연산 안해도 되니까
for i in range(2,x+1):
    
    #1을 빼는 경우 일단 -1하고 시작한다 => 1만 더해주면 된다
    d[i] = d[i-1] + 1

    #5로 나누어지는 경우 => -1뺀 현재 d[i]값과 비교해서 나눈 결과가 더 작을 경우 그 값으로 업데이트
    if i % 5 == 0:
        d[i] == min(d[i],d[i//5] + 1)

    #3로 나누어지는 경우 => -1뺀 현재 d[i]값과 비교해서 나눈 결과가 더 작을 경우 그 값으로 업데이트
    if i % 3 == 0:
        d[i] == min(d[i],d[i//3] + 1)    
    
    #2로 나누어지는 경우 => -1뺀 현재 d[i]값과 비교해서 나눈 결과가 더 작을 경우 그 값으로 업데이트
    if i % 2 == 0:
        d[i] == min(d[i],d[i//2] + 1)    


print(d[x])
